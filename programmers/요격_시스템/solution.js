function solution(targets) {
  let count = 0;
  let previousPosition = -1;

  // 개구간 중 끝지점을 기준으로 오름차순.
  targets.sort((a, b) => a[1] - b[1]);

  // 각 폭격미사일을 순회하면서,
  // 이전 요격지점에 포함되지 않는지를 체크한 후,
  // 포함되지 않는다면 count++하고 새로운 요격지점을 저장.
  // (요격지점은 항상 폭격미사일의 가장 끝지점으로 한다.)
  targets.forEach(([s, e]) => {
    if (previousPosition <= s) {
      // 포함되지 않는 구간.
      count++;
      previousPosition = e;
    }
  });

  return count;
}

/**
 * 1. 개구간의 끝지점을 기준으로 오름차순한다.
 * 2. 이렇게 정렬하고, 각 폭격 미사일을 순회한다.
 * 3. 그러면서 요격 좌표를 정하는데 요격 좌표는 폭격 미사일의 개구간 끝지점으로한다.(최초엔 -1로 지정)
 * 4. 순회하면서 이전 요격좌표에 현 폭격 미사일의 개구간 끝지점이 걸치는지 체크한다.
 * 5, 걸치면 같이 요격이 가능하다는 뜻. 걸치지 못한다면 새로운 요격좌표를 정해야하므로 count++
 *
 */
