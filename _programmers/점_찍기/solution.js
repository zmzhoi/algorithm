function calculateMaxY(d, x) {
  return Math.sqrt(Math.pow(d, 2) - Math.pow(x, 2));
}

function solution(k, d) {
  let count = 0;

  for (let x = 0; x <= d; x += k) {
    const maxY = calculateMaxY(d, x);
    console.log(maxY);
    count += Math.floor(maxY / k) + 1;
  }

  return count;
}

/**
 * 처음에는 역시나 이중 for문으로 접근했다. 그렇게 쉽게 풀려줄리가 없다.
 * 보통의 문제들처럼 효율성 부문에서 실패했다.
 * 그럼.. 이중 for문을 걷어내면 되는데 좋은 아이디어가 떠오르지 않아서 힌트를 보았다 🤗
 *
 * 한 번의 순회로 이 문제를 푸는 방법.
 * 원의 방정식이니 뭐니 하는 풀이들이 있었지만 내 방식대로 더 쉽게 풀이를 하겠다.
 * 점의 거리는 (x^2 + y^2) = d^2 의 식으로 구할 수 있다.
 * 이중 for문을 순회하면서 x와 y를 각각 k만큼 증가시키면서 모든 경우의 수를 다 계산하면 O(n^2)이 나온다.
 * 단 한번의 순회로 어떻게 해결할 수 있을까?
 * 점의 거리를 구하는 식을 보자.
 * x^2 + y^2 = d^2
 * x만 순회하면 순회하 때마다 나오는 x의 값과 d의 값을 가지고 현재의 x의 값에서 존재할 수 있는 y의 최대 값을 구할 수 있다.
 * d^2 - x^2 = y^2
 * 현 x에서 최대 y의 값을 알았으면 y를 k로 나눈 몫에 1을 더해주면 현 x에서의 존재할 수 있는 y의 경우의 수가 나온다.
 * 이렇게 x와 d의 값을 아는 상태에서는 최대 y의 값을 가지고 y의 경우의수를 알 수 있다.
 * 즉, x를 순회하면서 y의 경우의수를 모두 더하면 모든 경우의 수를 알 수 있다.
 *
 * 이중 순회 -> 순회
 *
 *
 *
 */
